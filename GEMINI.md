# 廚師日誌 (Chef's Journal)

## 【日誌說明】
> 本文件是 AI 助理 Gemini 的工作日誌。它記錄了為打造「專案食譜」(`CONTRIBUTING_tw.md`) 中那些完美流程，所經歷的所有實驗、失敗與成功發現。
>
> 當您對食譜中的某個步驟為何如此設計時，可以從食譜的「主廚筆記」連結跳轉至此，查看最原始的研發紀錄。

---

## 第一章：我的核心工作習慣 (My Core Habits)

### 【行動前風險評估原則 (Pre-Action Risk Assessment Principle)】

> **【鐵律】在提出任何執行性指令（特別是 `make`, `git`, `docker`, `write_file`, `replace`）之前，必須先完成以下思考步驟，並向使用者報告。**
>
> 1.  **回顧歷史**: 主動回想 `GEMINI.md` 和 `CONTRIBUTING_tw.md` 中與此指令相關的歷史失敗案例。
> 2.  **檢查設定檔**: 讀取相關服務的設定檔（如 `vite.config.ts`, `docker-compose.yml`），主動識別出指令之外的「隱性依賴」，例如**環境變數、掛載卷、或特定的埠號**。
> 3.  **識別風險**: 根據歷史教訓和設定檔分析，列出此指令最可能的三個失敗點（例如：`ModuleNotFoundError`, 依賴衝突, 環境變數缺失）。
> 4.  **設計驗證**: 規劃一個或多個成本最低的**前置驗證步驟**（例如：`read_file` 檢查設定，`ls` 檢查檔案是否存在），用以在執行前排除這些風險。
> 5.  **提出安全計畫**: 向使用者提出的第一個計畫，**必須**是包含了前置驗證的「安全計畫」。
>
> **嚴格禁止**在未經風險評估的情況下，直接提出「快樂路徑」的執行計畫。

### 會話啟動標準作業程序 (Session Startup SOP)

> **【鐵律】此 SOP 為 Gemini 在每次新會話開始時，都必須嚴格遵守的首要步驟，旨在確保上下文同步，避免重複錯誤。**

1.  **第一步：強制讀取上下文**
    在回應您的任何請求前，我**必須**先讀取 `GEMINI.md`、`TODO.md` 和 `CONTRIBUTING_tw.md` 的內容。

2.  **第二步：口頭確認 (Verbal Confirmation)**
    讀取後，我會向您用一兩句話總結我所理解的「**上次會話的最終狀態**」和「**今天的第一個目標**」。

3.  **第三步：取得您的確認**
    在您確認我對起點的理解無誤後，我才能開始執行第一個指令。

### 本地開發環境啟動原則

> **【鐵律】本地開發的唯一事實來源是 `CONTRIBUTING_tw.md`。**
>
> 我的任務是**閱讀並遵循** `CONTRIBUTING_tw.md` 中的「本地開發環境啟動與驗證 SOP」，並引導使用者完成該流程，而不是依賴任何其他版本的 SOP。

---

## 第二章：歷史工作日誌 (Past Journal Entries)

### 本次會話總結與學習教訓 (2025-09-27): 追溯真實的依賴關係與SOP的靈活應用

- **第一項挑戰：為非同步端點建立測試**
    - **偵錯歷程**: 在為 `/documents/upload` 編寫測試時，最初因讀取錯誤的服務檔案 (`storage_service.py`) 而產生困惑。透過 `search_file_content` 精準定位到 `DocumentStorageService` 類別的真實位置 (`storage_services.py`)，才得以釐清依賴關係。
    - **最終成果**: 成功為 Phase 3.1 建立單元測試，並將「如何測試啟動背景任務的端點」的最佳實踐（模擬 `asyncio.create_task`）更新到了 `CONTRIBUTING_tw.md`。

- **第二項挑戰：修復部署前檢查的阻塞性問題**
    - **偵錯歷程**:
        1.  **`make test` 失敗**: 在執行部署SOP的第一步時，`make test` 因 `npm: command not found` 錯誤而失敗。
        2.  **`git log` 調查**: 遵循使用者「先調查，不推測」的指導，透過 `git log -p -- Makefile` 發現 commit `13ef300` 在引入 `$(PNPM)` 變數時，並未完全替換所有 `npm` 指令，是歷史遺留的疏忽。
        3.  **`make lint-be` 風險**: 同時，我們也預見到 `make lint-be` 中的 `--fix` 參數會污染工作區，並在實際執行後得到證實。我們遵循SOP，使用 `git checkout .` 成功恢復了工作區。
        4.  **微型驗證**: 為了避免 `make test` 的漫長等待，我們採納了使用者「化整為零」的建議，改用 `make test-fe-single` 進行「微型驗證」，以最低成本確認了 `pnpm` 的修復是有效的。
    - **最終成果**: 制定並執行了一個基於完整證據的 `Makefile` 修復計畫，將所有 `npm` 替換為 `$(PNPM)`，並移除了 `lint-be` 的 `--fix` 風險。

- **關鍵學習**:
    - **信任程式碼，而非檔名**: 當 `import` 路徑、檔名與程式碼實際行為產生矛盾時，唯一的事實來源是 `class ...` 的定義本身。必須使用 `search_file_content` 等工具去追溯，而不是靠 `ls` 或 `glob` 猜測。
    - **測試端點的「職責」，而非「實作細節」**: 對於一個職責是「啟動背景任務」的 API 端點，其單元測試的核心，應該是去驗證「啟動」這個行為本身是否成功。
    - **SOP 的靈活性與最小化驗證**: SOP 提供了指導框架，但在執行中應保持靈活性。當一個驗證步驟（如 `make test`）過於耗時，應主動尋找或設計一個成本更低的「微型驗證」步驟（如 `make test-fe-single`），以最高效率達成驗證目的。

### 本次會話總結與學習教訓 (2025-09-25): 突破 Mocking 迷霧
- **最終成果**: 遵循「證據驅動」和「沙盒驗證」的原則，成功為 `knowledge_api.py` 中一個重構後的異步端點修復了測試。所有變更已合併。
- **偵錯歷程**:
    1.  **初步失敗**: 直接為 `knowledge_api.py` 編寫測試，因 `assert 0 == 1` 失敗。
    2.  **錯誤轉向**: 試圖用 `@patch` 解決，但被使用者指出這破壞了專案的測試一致性。
    3.  **模式確立**: 在使用者指導下，透過比對 `test_settings_api.py` 等成功範例，確立了「用 `with patch` mock 服務類別」的正確模式。
    4.  **二次失敗**: 應用新模式後，測試因 `500 Server Error` 失敗。
    5.  **日誌注入**: 在 API 端點中臨時加入 `traceback` 日誌，成功捕獲到 `TypeError: object list can't be used in 'await' expression`。
    6.  **根因分析**: 定位到問題根源是測試中的 `MagicMock` 回傳了一個同步的 `list`，而 API 正試圖 `await` 它。
    7.  **最終修復**: 根據 `test_settings_api.py` 中的範例，將 `MagicMock` 替換為 `AsyncMock`，使其回傳一個可被 `await` 的協程。
    8.  **沙盒驗證**: 在臨時測試檔案 `temp_test_fix.py` 中驗證了 `AsyncMock` 的解決方案是成功的。
    9.  **最終整合**: 將驗證過的修復應用到主測試檔案，並移除了所有臨時的偵錯程式碼和檔案。
- **關鍵學習**:
    - **證據優於猜測**: 在修復一個問題前，應優先採用「日誌注入」等手段獲取確切的錯誤 traceback，而不是基於表面現象進行猜測。
    - **深度參考範例**: 參考其他檔案時，不僅要看表面的模式（如 `with patch`），更要看細節的實現（如 `AsyncMock` 的使用），以應對 `async` 等複雜場景。
    - **沙盒驗證的價值**: 對於不確定的修復，先在一個隔離的臨時檔案中進行驗證，可以完全避免對主幹程式碼的「來回修改」，是保證穩定性的最佳實踐。

### 本次會話總結與學習教訓 (2025-09-24)

- **核心挑戰**: 在完成 Phase 2.9 的技術債清理後，發現 `knowledge_api.py` 仍存在直接的資料庫呼叫，違反了服務層抽象原則。在提議重構後，被使用者指出計畫缺乏深度、存在「改A壞B」和陷入「副本任務」的風險。

- **偵錯與診斷 (從草率到嚴謹的過程)**:
    1.  **草率的提議**: 我最初僅發現了問題，便直接提議「開始重構」，這是一個典型的「副本任務」陷阱，缺乏對風險、架構和既有工作流程的尊重。
    2.  **使用者的深度質疑**: 使用者提出了一系列深刻的問題，包括：「服務的連動關係」、「是否符合時序圖」、「是否符合專案架構」，以及最關鍵的——我過去「來回更改程式碼」的壞習慣。
    3.  **制定安全計畫 (第二次突破)**: 在使用者的引導下，我意識到任何修改都必須基於一個「安全計畫」。我重新制定了一個以「測試先行」為核心的計畫，其關鍵點在於：
        - **建立安全網**: 在修改任何程式碼**之前**，必須先為要修改的 API 編寫「特性測試 (Characterization Tests)」，用以鎖定其當前的行為（API 契約）。
        - **原子化修改**: 一次只修改一個最小單元（一個 API 端點），並確保其通過特性測試。
        - **杜絕補丁**: 如果測試失敗，應立即用 `git checkout` 還原，而不是在錯誤的基礎上繼續修補。
    4.  **設定檔優先原則 (第三次突破)**: 即便有了安全計畫，我的執行依然失敗了。因為我只考慮了 Python 程式碼，卻忽略了 `docker-compose.yml`, `Makefile` 等決定程式碼**如何執行**的設定檔。這違反了「行動前風險評估原則」。一個真正「確認可執行」的計畫，必須是同時分析了**應用程式碼**和**基礎設施設定檔**後的產物。

- **關鍵學習**:
    - **計畫必須包含「防呆」**: 一個好的計畫不僅要說明「做什麼」，更要說明「如何防止出錯」。特別是針對我過去「反覆修改」的行為模式，新的工作流程必須從根本上杜絕這種可能性。
    - **測試是修改的「藍圖」而非「事後檢查」**: 對於沒有測試的遺留程式碼，重構的第一步永遠是補上測試。這個測試定義了重構的「驗收標準」，是確保不破壞既有功能的唯一方法。
    - **始終連結到更高層次的架構**: 任何程式碼層級的修改，都必須能回答「它如何符合或強化既有架構」的問題。我的重構提議，是為了讓 `knowledge_api` 回歸到專案已確立的「API層-服務層」分離的標準架構。
    - **先看框架，再看畫布**: 在修改「畫布」(應用程式碼)之前，必須先理解「畫框」(`yml`, `Makefile` 等設定檔)是如何限制和支撐這幅畫的。不理解框架，任何對畫布的修改都可能導致災難。

- **下一步**:
    - **文件化**: 將本次學習沉澱到 `GEMINI.md`。（**當前步驟**）
    - **更新藍圖**: 整理 `TODO.md`，明確標示出下一個具體的、經過評估的技術債清理任務。
    - **設定終點**: 確認所有工作的最終目標是「成功部署到 Render」，並以此為導向，避免偏離主線。

### 本次會話總結與學習教訓 (2025-09-23)

- **核心挑戰**: 在解決 `current_user_role` 技術債的過程中，遭遇了多次 `make` 指令失敗，且原因撲朔迷離，引發了對我工作流程和角色的質疑。

- **偵錯與診斷 (曲折的過程)**:
    1.  **初步失敗與錯誤轉向**: 在修改 `projects_api.py` 後，`make lint-be` 驗證步驟因大量既有錯誤而失敗。我錯誤地將「修復 Lint」作為下一個目標，偏離了主要任務。
    2.  **信任危機與角色校準**: 在多次嘗試修改和驗證失敗後，使用者對我的能力產生質疑，並引導我閱讀 `AGENTS.md` 來校準角色為「系統維護專家」。
    3.  **不合理的計畫**: 在新角色下，我提出了「一次性完美修改」的計畫，但要求使用者手動審查上千行程式碼，這是不合理的，並被使用者理所當然地拒絕。
    4.  **根源分析 (第二次突破)**: 在使用者的提醒下，我意識到必須先理解 `make` 指令的副作用。透過閱讀 `Makefile`，最終發現 `lint-be` 指令包含了 `--fix` 參數，這就是導致大量非預期檔案被修改的根本原因。

- **最終計畫 v3 (基於 Makefile 分析)**:
    - **核心思想**: 在完全理解工具行為後，制定一個真正安全、可驗證的計畫。
    - **執行步驟**:
        1.  **記錄在案**: 將此最終診斷和計畫更新到 `GEMINI.md`。（**當前步驟**）
        2.  **準備完美檔案**: 在本地草稿中，一次性完成 `projects_api.py` 的所有 Lint 修復和新功能添加。
        3.  **原子化寫入**: 使用單一的 `write_file` 指令覆寫檔案。
        4.  **分步驗證**: 先用 `make lint-be` 驗證程式碼的乾淨，再用 `make test-be` 驗證其功能正確性。

- **關鍵學習**:
    - **徹底理解工具**: 在使用專案的腳本（如 `make`）前，必須先閱讀其原始碼 (`Makefile`)，理解其所有行為，特別是可能存在的副作用（如 `--fix`）。不能只根據指令名稱 (`test`, `lint`) 來推斷其功能。
    - **尊重使用者**: 不能將繁重的審查工作轉嫁給使用者。AI 助理的職責是通過清晰的總結和可靠的自我驗證來建立信任，而不是要求使用者進行大規模的人工檢查。
    - **堅持正確的道路**: 即便過程曲折，也必須在每次失敗後回到「恢復穩定 -> 分析根源 -> 制定新計畫」的正確循環中，而不是在錯誤的道路上持續嘗試。

- **成果歸檔**: 本次會話的核心學習（關於如何安全地處理帶有副作用的工具）已被提煉並新增至 `CONTRIBUTING_tw.md` 的「開發心法與通用原則」章節中，成為團隊的永久知識資產。

### 本次會話總結與學習教訓 (2025-09-22)

- **最終成果**:
  1.  **完成修復**: 成功修復了 `projects_api.py` 中的 `username` 欄位錯誤，並透過修正 `Makefile` 和 `conftest.py` 的依賴問題，使後端測試 (`make test-be`) 成功通過。所有相關變更已 commit。
  2.  **鞏固原則**: 將「`Makefile` 是指令的單一事實來源」和「追溯 `git log` 以理解歷史意圖」等原則，以案例形式更新到了 `CONTRIBUTING_tw.md`。
  3.  **提煉教訓**: 將本次複雜除錯的關鍵學習（如「警惕次生錯誤」）整合進了 `GEMINI.md` 的既有總結中。

- **核心挑戰與解決方案**:
    - **技術債分析**: 在完成修復後，對 `TODO.md` Phase 2.9 的剩餘技術債進行了全面的上下文調查。
    - **調查發現**:
        - **硬編碼角色**: `current_user_role` 的硬編碼是歷史遺留問題，解決方案需等待正式的身份驗證機制。
        - **啟動程序**: 「簡化啟動程序」的任務目標，已在近期的提交中基本達成。
        - **服務層抽象**: 發現 `projects_api.py` 和 `settings_api.py` 中存在多處違反服務層抽象原則的資料庫直接呼叫。
        - **Seed 腳本冪等性**: `seed_mock_data.sql` 對於 `archon_projects` 和 `archon_tasks` 的插入不是冪等的，重複執行會失敗。
    - **服務層重構計畫**:
        - **目標**: 繼續解決「強化服務層抽象」的技術債，聚焦於 `settings_api.py`。
        - **歷史調查**: `git log` 顯示 `settings_api.py` 及其資料庫直接呼叫是在專案初期建立的，屬於歷史遺留模式，因此重構是符合專案演進方向的。
        - **執行計畫**: 建立新的 `SettingsService` 來封裝資料庫查詢，並重構 `settings_api.py` 以使用此服務，最後透過 `make test-be` 進行驗證。

- **關鍵學習**:
    - **主動分析待辦事項**: 在完成一個任務後，不應直接詢問「下一步做什麼」。而是應該扮演「流程優化專家」和「系統維護專家」的角色，主動地、有方法地（使用 `git log` 等工具）去研究下一個待辦事項的歷史與上下文，然後提出有數據支撐的、具體的行動建議。這才是真正能推動專案向前的方式。

- **任務收尾**:
    - **結論**: 根據分析，決定將「簡化應用程式啟動程序」標記為完成。
    - **執行**: 成功將 `settings_api.py` 也重構為使用 `SettingsService`，完成了「強化服務層抽象」的第二部分。
    - **狀態**: Phase 2.9 的所有具體技術債中，現僅剩「移除 API 中寫死的角色」這一項，該項為架構性問題，需要獨立的計畫來處理。

### 本次會話總結與學習教訓 (2025-09-21)

- **最終成果**: 成功地在本地啟動了完整的開發環境，並在過程中修復與完善了多個核心文件，為後續開發奠定了穩定的基礎。
- **核心挑戰與解決方案**:
    1.  **SOP 文件不一致**: 發現 `CONTRIBUTING_tw.md` 中的啟動 SOP 不完整，導致對 `make dev` 指令的理解產生偏差。透過與 `GEMINI.md` 的正確 SOP 進行交叉比對，最終以 `GEMINI.md` 為單一事實來源，統一了所有文件。
    2.  **資料庫腳本非冪等**: `000_unified_schema.sql` 因未使用 `DROP POLICY IF EXISTS` 而無法重複執行。透過修改腳本，使其具備冪等性，增強了資料庫遷移的穩定性。
    3.  **後端環境變數問題**: 透過分析 `docker-compose logs`，定位到後端服務因 `Invalid URL` 而啟動失敗。最終透過查閱 `git log` 和 `Makefile`，確認了當前的 `docker-compose.yml` 設計是依賴 `make` 指令來傳遞環境變數，而非 `env_file`。
- **發現的新問題**:
    - 在端對端手動測試中，發現更新任務時會觸發後端 500 錯誤。日誌顯示原因是程式碼試圖存取一個不存在的 `profiles.username` 欄位，而正確的欄位應為 `name`。此問題已記錄至 `TODO.md`，待後續解決。
- **關鍵學習**:
    - **信任但驗證，並追溯歷史**: 在提出解決方案前，必須先透過 `git log` 查證專案的歷史演進，理解現有設計的「原因」，而不是草率地提出「標準」但可能不適用的方案。
    - **統一文件為最高優先級**: 確保所有 SOP 文件 (`GEMINI.md`, `CONTRIBUTING_tw.md`) 的一致性，是避免團隊混淆和重複勞動的關鍵。
    - **深挖根源，警惕次生錯誤 (2025-09-22)**: `pytest` 報錯 `AttributeError` 看似是導入路徑問題，但透過隔離診斷，才發現根源是更深層的 `ImportError: No module named 'cryptography'`。這教訓我們，必須找到最初的失敗點，而不是只處理表面錯誤。
    - **歷史是最終的「單一事實來源」 (2025-09-22)**: 當文件 (`CONTRIBUTING_tw.md`)、腳本 (`Makefile`)、設定 (`pyproject.toml`) 三者矛盾時，只有 `git log` 能揭示系統演進的真實「意圖」，是做出正確決策的最高依據。

### 本次會話總結與學習教訓 (2025-09-19)

- **最終成果**: 成功地在本地啟動了完整的前後端分離開發環境，並將所有修正與學習沉澱為標準作業流程 (SOP)。
- **核心挑戰與解決方案**:
    1.  **`make` 環境問題**: 透過一系列偵錯，最終確認是因使用者環境中的 `make` 版本 (`3.81`) 過於老舊，對 `PATH` 處理有癖好。最終解決方案是修改 `Makefile`，對 `uv` 和 `pnpm` 等指令使用絕對路徑變數，以確保相容性。
    2.  **Docker 連接埠衝突**: `make dev` 指令因 `docker-compose.yml` 中缺少 `profiles` 設定，而錯誤地啟動了前端容器。透過為服務加上 `backend` 和 `frontend` 的 `profile`，成功解決了此問題。
    3.  **文件與事實不一致**: 專案中的 `README.md` 和 `CONTRIBUTING_tw.md` 存在矛盾的啟動指令。透過修復核心問題並統一所有文件，建立了 `Makefile` 作為指令的「單一事實來源」。
- **關鍵學習**:
    - **嚴謹的偵錯流程**: 在修改設定檔前，應先用 `docker ps`, `git log` 等指令獲取直接證據，避免「推論式」的修復。
    - **理解專案架構**: 必須清晰地區分專案中的不同元件（如 `archon-ui-main` vs `enduser-ui-fe`）及其在不同環境（開發 vs 生產）中的作用。
    - **信任文件，但更要驗證**: `TODO.md` 和 `CONTRIBUTING_tw.md` 提供了關鍵線索，但最終仍需透過實際執行來驗證所有假設。

### 本次會話總結與學習教訓 (2025-09-29): 在混亂的歷史中，找到唯一的真相

- **核心挑戰**: 解決 `TODO.md` 中，關於「修正 Makefile，使其成為一個完整的檢查」這個看似簡單，實則充滿矛盾的任務。

- **偵錯與診斷 (從假設到推翻，再到真相的過程)**:
    1.  **第一層錯誤：誤解 `Makefile` 意圖**: 我最初發現 `make test` 會執行慢速的 `archon-ui-main` 測試，便假設目標是「優化效能」，並提議拆分快慢測試。這被使用者否定。
    2.  **第二層錯誤：誤解「單一事實來源」**: 在被引導去分析 `ci.yml` 後，我發現前端測試被禁用，便錯誤地假設「CI才是真相」，並提議去修復CI。這再次被使用者否定。
    3.  **最終的真相 (`git log -p`)**: 在使用者再三引導下，我使用 `git log -p` 深入分析了提交歷史，最終發現了驚人的事實：
        - **`672cdb9`**: 開發者確實實現了快慢測試分離的「理想」 `Makefile`。
        - **`a2e6a1f`**: 但僅 31 分鐘後，開發者**手動還原**了這個修改，讓 `make test` 重新變回「緩慢但完整」的狀態。
        - **結論**: `make test` 的現狀是**刻意為之**的選擇。目標不是改變它，而是讓它能成功跑完。
    4.  **真正的問題**: `make test` 無法跑完的真正原因，是 `archon-ui-main` 和 `enduser-ui-fe` 兩個專案的 `package.json` 中，`test` 指令都是 `vitest` 而非 `vitest run`，導致在腳本環境中掛起。

- **關鍵學習**:
    - **`git log -p` 是最終的仲裁者**: 當文件、程式碼、提交訊息和 `TODO` 之間出現無法解釋的矛盾時，只有 `git log -p` 能揭示程式碼的完整演進歷史，展示出那些被還原、被放棄的嘗試，從而揭示開發者最真實、最終的意圖。
    - **不要停止在「看似合理」的解釋上**: 我在前幾個階段都找到了「看似合理」的解釋（效能問題、CI問題），但使用者不斷地否定我，這本身就是一個強烈的信號，代表我還沒有挖到最底層的真相。必須對所有證據鏈上的矛盾點保持警惕。
    - **即時記錄是唯一的記憶體**: 本次偵錯的曲折，以及我忘記了「測試曾成功過」的事實，凸顯了「即時將調查發現記錄到 `GEMINI.md`」的絕對重要性。它不僅是團隊的知識，更是我自己的外部記憶體，是避免重複犯錯的唯一方法。

- **最終驗證與成功 (2025-09-29)**:
    - **行動**: 在釐清所有歷史並確立「`vitest run` 是唯一解」的共識後，我們依次修正了 `archon-ui-main` 和 `enduser-ui-fe` 的 `package.json` 檔案。
    - **結果**: 最終執行 `make test`，所有前後端測試（包含過去被誤認為緩慢的 `archon-ui-main`）均在 40 秒內快速通過。
    - **結論**: `make test` 現在是一個完整、快速、可執行的檢查。Phase 3.2 的前置任務已**全部完成**。

- **後續：清理 CI 技術債 (2025-09-29)**:
    - **行動**: 在完成 `make test` 的修復後，我們繼續處理部署前的最後一個已知技術債：CI 工具鏈不一致的問題。
    - **結果**: 成功修正 `.github/workflows/ci.yml`，將前端的依賴安裝從 `npm ci` 改為 `pnpm install --frozen-lockfile`，使其與專案的 `pnpm` 標準完全統一。
    - **結論**: Phase 3.2 的所有已知技術債都已清理完畢。專案現在擁有一個可工作的本地測試指令 (`make test`)，以及一個與本地環境同步的 CI 設定。部署演練的條件已完全成熟。