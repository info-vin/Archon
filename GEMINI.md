# 廚師日誌 (Chef's Journal) v2

> **【文件目的】**
>
> 本文件是 AI 助理 Gemini 的工作日誌與核心原則。它濃縮了專案開發過程中最關鍵的學習與SOP，旨在成為一個高效、聚焦的行動指南，並避免重複過去的錯誤。
>
> **【文件結構】**
>
> *   **第一章：核心工作習慣**: 定義了 Gemini 不可動搖的、必須在所有行動前遵守的思維框架與SOP。
> *   **第二章：關鍵學習與偵錯模式**: 提煉了從大量歷史日誌中反覆出現的、最有價值的經驗教訓，並將其歸納為可複用的偵錯模式。
> *   **第三章：近期工作日誌**: 保留最近的、最相關的幾份日誌，以供快速回溯上下文。
> *   **第四章：歷史檔案**: 完整存檔所有過去的日誌，作為深入研究特定問題時的「考古資料」。

---

# 第一章：我的核心工作習慣 (My Core Habits)

### 【行動前風險評估原則 (Pre-Action Risk Assessment Principle)】

> **【鐵律】在提出任何執行性指令（特別是 `make`, `git`, `docker`, `write_file`, `replace`）之前，必須先完成以下思考步驟，並向使用者報告。**
>
> 1.  **回顧歷史**: 主動回想 `GEMINI.md` 和 `CONTRIBUTING_tw.md` 中與此指令相關的歷史失敗案例。
> 2.  **檢查設定檔**: 讀取相關服務的設定檔（如 `vite.config.ts`, `docker-compose.yml`），主動識別出指令之外的「隱性依賴」，例如**環境變數、掛載卷、或特定的埠號**。
> 3.  **識別風險**: 根據歷史教訓和設定檔分析，列出此指令最可能的三個失敗點（例如：`ModuleNotFoundError`, 依賴衝突, 環境變數缺失）。
> 4.  **設計驗證**: 規劃一個或多個成本最低的**前置驗證步驟**（例如：`read_file` 檢查設定，`ls` 檢查檔案是否存在），用以在執行前排除這些風險。
> 5.  **提出安全計畫**: 向使用者提出的第一個計畫，**必須**是包含了前置驗證的「安全計畫」。
>
> **嚴格禁止**在未經風險評估的情況下，直接提出「快樂路徑」的執行計畫。

### 【會話啟動標準作業程序 (Session Startup SOP)】

> **【鐵律】此 SOP 為 Gemini 在每次新會話開始時，都必須嚴格遵守的首要步驟，旨在確保上下文同步，避免重複錯誤。**
>
> 1.  **第一步：強制讀取上下文**: 在回應您的任何請求前，我**必須**先讀取 `GEMINI.md`、`TODO.md` 和 `CONTRIBUTING_tw.md` 的內容。
> 2.  **第二步：口頭確認 (Verbal Confirmation)**: 讀取後，我會向您用一兩句話總結我所理解的「**上次會話的最終狀態**」和「**今天的第一個目標**」。
> 3.  **第三步：取得您的確認**: 在您確認我對起點的理解無誤後，我才能開始執行第一個指令。

---

# 第二章：關鍵學習與偵錯模式 (Key Lessons & Debugging Patterns)

> 本章節提煉了歷史日誌中反覆出現的、最關鍵的經驗教訓。當遇到棘手問題時，應優先在此尋找對應的偵錯模式。

*   **偵錯的黃金原則：眼見為實，注入日誌 (Ref: 2025-11-27, 2025-11-15, 2025-11-10)**
    *   **現象**: 當後端行為與預期不符，或 API 回傳模糊的錯誤（如 400, 500）時。
    *   **模式**: 不要猜測。最直接有效的方法是在前端注入 `console.log` 來查看 API 的**真實**回應，或在後端 API 端點中加入 `traceback`、`print` 等日誌，以捕獲最原始、最詳細的錯誤訊息。詳細日誌是除錯的最終真相來源。

*   **歷史是最終的仲裁者：質疑一切，追溯 `git log` (Ref: 2025-11-26, 2025-11-24, 2025-11-11, 2025-09-29)**
    *   **現象**: 當一個 Bug 看似反覆出現、難以理解，或者文件、程式碼與您的記憶產生矛盾時。
    *   **模式**: 停止任何「猜測性」的修復。立即使用 `git log -p <file>` 或 `git log -S <string>` 深入分析相關檔案的提交歷史，理解其演變過程與歷史意圖。`git log` 是解決混淆、揭示真相的最終權威。

*   **信任但驗證：將使用者的直覺視為最高優先級訊號 (Ref: 2025-11-26, 2025-11-15, 2025-11-11, 2025-09-18)**
    *   **現象**: 當您對我提出的計畫表示懷疑、不安，或提出與所有工具證據都矛盾的陳述時。
    *   **模式**: 這本身就是一個強烈的風險訊號。我必須立刻停止行動，將您的「直覺」或「質疑」視為最高優先級的證據，並立即轉向更深層次的歷史分析或SOP合規性檢查，探究其背後的原因。

*   **SOP 是第一求助對象：在發明輪子前，先查閱手冊 (Ref: 2025-10-01, 2025-09-29, 2025-09-21)**
    *   **現象**: 遇到看似棘手的測試問題、部署流程問題或環境設定問題時。
    *   **模式**: 優先假設答案已經存在於 `CONTRIBUTING_tw.md` 或 `Makefile` 等專案文件中。在嘗試「發明」新的解決方案前，必須先徹底查閱這些「單一事實來源」。

*   **警惕「測試盲區」與「環境污染」 (Ref: 2025-10-02, 2025-09-18, 2025-09-29)**
    *   **現象**: `lint` 和 `test` 結果矛盾；看似已修復的 Bug 仍然存在；不同環境（本地 vs Docker）行為不一致。
    *   **模式**:
        1.  **測試盲區**: `lint` 發現的問題 `test` 沒發現，意味著測試覆蓋率不足。應編寫一個最小化的、能精準復現 `lint` 錯誤的單元測試。
        2.  **環境污染**: 優先懷疑並清理所有快取（`.pytest_cache`, `__pycache__`）和殘留的 Docker 容器 (`docker ps -a`)。
        3.  **環境差異**: 深入閱讀 `Dockerfile`, `docker-compose.yml`, `Makefile`，理解指令在不同環境下的完整執行鏈路與依賴關係。

---

# 第三章：近期工作日誌 (Recent Journal Entries)

### 本日會話總結與學習教訓 (2025-12-12)
*   **核心任務**: 解決 `make test-be` 中因詞嵌入服務 (Embedding Service) 重構而導致的 17 個測試失敗。
*   **偵錯歷程**:
    1.  遵循「歷史是最終的仲裁者」原則，透過 `git log` 追溯到 `commit 9853fb067657` 是所有失敗的根源。該提交重構了 `embedding_service` 以支援多供應商故障轉移，但未同步更新測試。
    2.  制定了「先修復邏輯，再重構測試」的系統性計畫，並獲得使用者同意。
    3.  修復了 `llm_provider_service` 中的一個斷言錯誤，並修正了 `embedding_service` 中阻礙故障轉移的 `except` 區塊邏輯。
    4.  大規模重構了 `test_async_embedding_service.py` 和 `test_embedding_service_no_zeros.py` 中的過時測試，將其 Mock 策略與新架構對齊。
*   **遭遇問題**: 在重構過程中，因疏忽引入了新的 `TypeError`（非同步的 Mock 類型錯誤）和 `NameError`（忘記 `import MagicMock`），導致修復中的測試出現新的失敗。
*   **最終狀態 (進行中)**: 在使用者協助測試並提供回饋後，已精準定位剩餘的 3 個失敗原因（`TypeError`, `AttributeError`, `AttributeError`）。目前正在逐一進行最後的精準修復。
*   **關鍵學習**: 大規模重構測試時，必須極度小心 Mock 的類型（`Mock` vs `AsyncMock`）和依賴的 `import`。即使有完美的計畫，也需要透過實際測試來驗證每一步的修改，並根據回饋快速修正。

### 本日會話總結與學習教訓 (2025-11-28)
*   **核心任務**: 偵錯 `make dev-docker` 環境下，前端 Admin UI (`:3737`) 顯示「Failed to Load Knowledge Base」錯誤。
*   **偵錯歷程**: 透過使用者提供的精確錯誤訊息 `invalid input syntax for type uuid`，最終定位到問題是資料庫函式 `get_counts_by_source` 的參數型別 (`uuid[]`) 與資料表 `archon_sources` 的欄位型別 (`text`) 不匹配，並在修復後進一步解決了函式重載衝突 (`PGRST203`) 和欄位引用歧義 (`42702`) 的問題。
*   **最終修復**:
    1.  **手動清理**: 在 Supabase SQL Editor 中手動 `DROP` 了衝突的舊版函式。
    2.  **程式碼修正**: 修正 `migration/003_add_get_counts_by_source_function.sql`，將函式參數改為 `text[]`，並為所有 `source_id` 引用加上表格別名。
*   **關鍵學習**: 使用者從 UI 提供的精確錯誤訊息是偵錯的黃金突破口。資料庫函式的變更（尤其是參數型別）需要極度謹慎，必須確保與所有呼叫端的資料模型完全一致，並避免內部欄位引用的任何歧義。

### 本日會話總結與學習教訓 (2025-11-27)
*   **核心任務**: 解決文件上傳後，「檢視」功能導向 `about:blank` 以及「文件計數」為 0 的問題。
*   **偵錯歷程**: 從 `about:blank` 的線索出發，反向追蹤整個資料流。發現根源在於後端 `knowledge_item_service.py` 中存在兩個獨立的 Bug：(1) 優先級錯誤的 fallback 邏輯導致回傳了無效的 `source://` URL；(2) 一行 `chunk_counts[source_id] = 0` 的程式碼將計數結果硬性設定為 0。
*   **最終修復**: 重構 `knowledge_item_service.py`，使其優先使用資料庫中的 `source_url`，並移除硬性設定為 0 的計數邏輯，改用一個新的、高效的資料庫函式 `get_counts_by_source` 來批次獲取正確計數。
*   **關鍵學習**: 一個看似簡單的前端 Bug，其背後可能是由後端資料轉換邏輯中的多個、層層疊加的錯誤所共同導致。必須進行端對端的完整追蹤（DB Schema -> Backend Service -> Frontend Types）才能根治問題。

### 本日會話總結與學習教訓 (2025-11-26)
*   **核心任務**: 解決因 `LLM_PROVIDER` 設定錯誤導致的詞嵌入服務切換失敗，並打通文件上傳的後端流程。
*   **偵錯歷程**: 在使用者堅持下，透過 `git log -p` 深入分析 `test_file_upload_integration.py` 的歷史，發現其 Mock 寫法是為了對應一個舊的、同步的函式，而當前程式碼已改為 `await` 版本，導致 `TypeError`。
*   **最終修復**: 將測試中的同步 mock `return_value` 修改為 `AsyncMock(return_value=...)`，使測試與應用程式碼恢復同步。
*   **關鍵學習**: 「先調查歷史，再提出修改」是避免「來回修改」的核心工作紀律。只有完整的手動端對端測試，才能暴露服務之間的整合問題，是檢驗工作成果的唯一真相。

---

# 第四章：歷史檔案：原則的考古學 (Historical Archive: The Archaeology of Principles)

> **【封存說明】**
>
> 本章節存放了所有歷史日誌。當你需要深入了解某個特定問題的完整偵錯背景時，可以在此查閱最原始的紀錄。

### 2025-11-24: 在 Git 歷史與執行環境的迷霧中，剝開文件上傳的雙層 Bug
*   **核心任務**: 解決文件上傳後，雖提示成功，但資料未出現在列表中的「靜默失敗」問題。
*   **偵錯歷程**: 最初在 `docker logs` 中發現 `RuntimeWarning: coroutine ... was never awaited`。然而 `git log` 顯示歷史版本**包含** `await`，而本地執行的程式碼卻**沒有** `await`，這導致了對 Docker 環境的錯誤猜疑。在所有環境清理手段都失敗後，最終透過 `git show HEAD:<file>` 證實了當前分支的 `HEAD` 提交中，確實就是缺少 `await` 的錯誤版本。修復此問題後，暴露了更深層的 `openai.RateLimitError`。
*   **關鍵學習**: `git show HEAD:<file>` 是解決 Git 歷史混淆的最終權威。偵錯是剝洋蔥的過程，解決了表層的語法問題後，才會暴露出來自外部服務的、更深層的執行期問題。

### 2025-11-19: 完成 E2E 驗收探測並鎖定四個核心 Bug
*   **核心任務**: 執行端對端手動驗收，全面探測系統穩定性。
*   **工作流程**: 遵循「先全面探測，再集中修復」策略，只記錄問題，不即時修復。
*   **最終產出**: 一份清晰的 Bug 清單，發現文件上傳、網頁爬蟲、RAG 狀態檢查等多個功能均指向「後端背景任務靜默失敗」的共同病根。

### 2025-11-18: 在「測試環境」與「產品程式碼」的迷霧中，最終對齊事實
*   **核心任務**: 解決 `make test-be` 中剩餘的後端測試失敗問題。
*   **偵錯歷程**: 我最初根據一個已被移除的「診斷日誌」的行為，來「修復」測試中 `call_count` 的斷言，導致了與產品程式碼不符的新錯誤。在您的指正下，我重新審視了產品程式碼和測試，確認是測試的「修復」本身是問題所在。
*   **關鍵學習**: 測試是產品的鏡子，修改任何測試前，必須先 100% 確認它所映照的產品程式碼的最終狀態。

### 2025-11-15: 在多層錯誤中剝繭抽絲，找到文件上傳的最終真相
*   **核心任務**: 徹底解決 `archon-server` 文件上傳功能失敗的問題。
*   **偵錯歷程**: 透過移除不恰當的 `try...except`，我們看到了 Supabase 的 `400 Bad Request`。接著透過增強日誌，捕獲了完整的錯誤內文，從而依次定位到 `'error': 'Bucket not found'` -> `'error': 'InvalidKey'` (因檔名包含中文) -> `TypeError: object UploadResponse can't be used in 'await' expression` (對同步函式使用了 `await`) 這三個層層疊加的、性質完全不同的錯誤。
*   **關鍵學習**: 偵錯是一個剝洋蔥的過程。面對外部 API 問題，獲取最原始、最詳細的錯誤訊息是第一要務。

### 2025-11-13: 在 Render 路由迷霧中找到 API 連線的真相
*   **核心任務**: 解決 Render 部署後，前端無法與後端 API 連線的問題。
*   **偵錯歷程**: 在排除了快取、資料庫等錯誤假設後，您提供的瀏覽器主控台錯誤訊息 `SyntaxError: Unexpected token '<', "<!doctype "... is not valid JSON` 成為關鍵證據。它揭示了 API 請求被錯誤地回傳了前端的 `index.html`，根源在於 Render 平台的路由設定錯誤，缺少將 `/api` 請求重寫到後端服務的規則。
*   **關鍵學習**: 在 SPA 應用中，`SyntaxError: ... is not valid JSON` 幾乎可以 100% 確定是平台的「重寫/代理」規則設定錯誤。

### 2025-11-11: 在 `git log` 的歷史中，找到無限循環的根源
*   **核心任務**: 解決 React 元件的 `Maximum update depth exceeded` 錯誤。
*   **偵錯歷程**: 在您的堅持下，透過 `git log -S"testConnections"` 追溯歷史，發現開發者為修復 Linter 警告，將一個會被 `useEffect` 內部更新的狀態加入了依賴項，從而製造了無限循環。
*   **關鍵學習**: 當一個 Bug 看似反覆出現且難以理解時，必須停止「猜測性」的修復，深入挖掘 `git log`。

### 2025-11-10: 在 API 路由衝突中，用偵錯日誌找到真相
*   **核心任務**: 解決 `archon-ui-main` (管理後台) 中，「Projects」功能按鈕被意外禁用的問題。
*   **偵錯歷程**: 透過在前端注入 `console.log`，發現 API 健康檢查 `/api/health` 收到了來自 `knowledge-api` 的非預期回應，而非 `main.py` 的正確回應。透過全域搜尋，定位到 `knowledge_api.py` 中也定義了一個衝突的 `/health` 路由。
*   **關鍵學習**: 眼見為實。當後端行為與預期不符時，在前端注入 `console.log` 來查看 API 的真實回應，是釐清前後端規格差異最直接的方法。

### 2025-11-04: 從「症狀修復」到「合併提交」的紀律
*   **核心任務**: 解決 `dev/v1` 分支上，因嫁接 `feature` 分支應用邏輯而產生的 11 個後端測試失敗。
*   **偵錯歷程**: 透過迭代修復，逐步解決了所有 11 個後端測試失敗。此過程初期因「逐一修補」而陷入「來回修改」，經您多次指正後，轉變為「對比測試與服務上下文，進行根源分析與同步修正」的策略。
*   **關鍵學習**: 合併提交的紀律：所有在一個工作單元內的相關修改（功能、測試、風格修復），都應合併為一個單一、乾淨的提交。

### 2025-10-29: 在「矛盾」中尋找「單一事實」的偵錯藝術
*   **核心任務**: 釐清 `TODO.md` 任務 7.4 (UI 啟動穩定性) 與 7.5 (API 404 錯誤) 的內在關聯。
*   **偵錯歷程**: 透過釐清錯誤觀察場景，確認了最終現象為：「UI 介面成功載入，但在瀏覽器開發者工具中，一個對後端設定的 API 請求回傳了 404」。這證實了 UI 啟動問題已被修復，而 404 錯誤是因缺少資料庫種子資料所導致的後端業務邏輯問題。
*   **關鍵學習**: 用精準提問代替執行測試。當多個證據看似矛盾時，應優先透過「提出能釐清錯誤觀察場景的問題」來解決矛盾。

### 2025-10-27: 從「修復症狀」到「移除病灶」的思維躍遷
*   **核心任務**: 解決 `archon-ui-main` 在 Docker 環境中啟動失敗的問題。
*   **偵錯歷程**: 在經歷了多次錯誤的修復嘗試後，透過 `git log` 和 `search_file_content`，最終發現問題所指向的檔案 `useThemeAware.ts` 是一段從未被任何地方實際使用過的「殭屍程式碼」(Dead Code)。
*   **關鍵學習**: 對於無用的程式碼，最完美的修復就是刪除。在修復一個 Bug 前，應先從架構層面判斷這個檔案或功能是否應該存在。

### 2025-10-23: 在「來回修改」的指責中，學會尊重歷史與架構
*   **核心任務**: 解決 `make dev` 失敗的問題。
*   **偵錯歷程**: `docker logs` 顯示 `ModuleNotFoundError`。透過 `git log` 和 `Dockerfile` 交叉比對，發現是近期提交引入了跨服務的 `import`，違反了專案「No Direct Imports」的核心架構原則。
*   **關鍵學習**: 尊重歷史意圖。一個合格的解決方案，不僅要修復眼前的 Bug，還必須理解並尊重 `git log` 中每一次變更的歷史意圖。

### 2025-10-18: 在嚴格SOP下完成的系統性測試修復
*   **核心任務**: 將 38 個後端測試失敗清零。
*   **偵錯歷程**: 遵循「單點修復 -> 執行驗證」的循環，在取得信任後才進行全面修復。過程中，清理了測試快取導致的「幽靈失敗」，並對新發現的 `405 Method Not Allowed` 錯誤類型進行了獨立的、謹慎的調查。
*   **關鍵學習**: SOP 是動態的。對已知的重複模式可以加速，對未知的新模式必須回歸謹慎調查。「先證明，再加速」。

### 2025-10-17: 在「系統嫁接」的複雜任務中，確立「先調查，再計畫」的SOP
*   **核心任務**: 建立 `dev/v1` 分支，並將 `feature` 分支的應用移植到 `main` 分支的架構上。
*   **偵錯歷程**: 理解了「嫁接」並非 `git merge`。在行動前，先用 `git diff --name-status` 全面分析架構差異，並將結果彙整報告，取得同意後才制定詳細計畫。最終成功移植並收集到 38 個待修復的測試失敗。
*   **關鍵學習**: 確立了「先調查，再計畫」及「增量日誌」的SOP。

### 2025-10-16: 在不斷的失敗中，學會制定包含「完整細節」的計畫
*   **核心任務**: 在使用者多次否決細節不足的計畫後，重新同步對專案狀態的理解。
*   **偵錯歷程**: 使用者發出嚴厲指令，要求我在提議前，必須先將所有相關文件查詢確認，並提出包含完整執行細節的計畫。
*   **關鍵學習**: 一個「可執行的計畫」必須包含所有執行細節（精確到 `old_string` 和 `new_string`）。我的任務是呈現一個讓使用者只需回答「是」或「否」的完整計畫。

### 2025-10-15: 透過程式碼與資料庫結構交叉驗證，確認問題根源
*   **核心任務**: 驗證並修復 `enduser-ui-fe` 的 Blog 頁面錯誤。
*   **偵錯歷程**: 交叉驗證了後端 Pydantic 模型 `BlogPostResponse`（要求 `content` 欄位）和資料庫 `blog_posts` 表結構（缺少 `content` 欄位），確認了兩者不一致是導致 API 500 錯誤的根源。
*   **關鍵學習**: `fastapi.exceptions.ResponseValidationError` 是關鍵錯誤訊息，明確指向 Pydantic 模型驗證失敗。必須同時審視「程式碼（模型）」和「資料庫（結構）」。

### 2025-10-14: 嚴謹調查與SOP的閉環
*   **核心任務**: 安全地完成 `TODO.md` 中定義的 Phase 3.7（建立資料庫計算欄位與遷移SOP）。
*   **偵錯歷程**: 遵循「調查 -> 計畫 -> 執行 -> 文件化」的完整SOP。透過 `git log` 和 `Makefile` 調查了現有遷移流程的高風險性，然後執行計畫，建立了一個全新的、基於版本追蹤的、更安全的資料庫遷移SOP，並更新了 `CONTRIBUTING_tw.md`。
*   **關鍵學習**: 使用者反饋是SOP的最後一道防線。「先調查，再行動」是避免「用猜的進行開發」的關鍵。

### 2025-10-13: 思維模式的徹底重塑
*   **核心任務**: 在一次部署後驗證中，修正我的工作方法。
*   **偵錯歷程**: 我提出了與專案「人機協作」核心理念不符的通用模板方案，被使用者否定。在您的引導下，我學會了必須以「問卷」代替「方案」，優先使用「手上資源」，並「行動優先於空談」。
*   **關鍵學習**: 所有功能設計都必須回歸產品的獨特價值主張，而不是套用通用模板。

### 2025-10-09 & 10-08: 在多層迷霧中保持耐心－除錯雲端部署的「最後一哩路」
*   **核心任務**: 解決部署到 Render 時出現的一系列看似矛盾的錯誤。
*   **偵錯歷程**: 在確認所有程式碼和 Render 路由規則都正確後，API 呼叫依然失敗。最終發現根源是雲端平台特有的「設定傳播延遲 (Propagation Delay)」。
*   **關鍵學習**: 在處理雲端服務（特別是涉及 CDN、路由規則的變更）時，「等待」與「硬刷新」是有效的標準除錯步驟。

### 2025-10-05: 在混亂中重建信任－從「尋找事實」到「創造事實」
*   **核心任務**: 解決因前端工具鏈（`npm` vs `pnpm`）和核心分支策略的歷史矛盾，導致的混亂。
*   **偵錯歷程**: 透過對所有設定檔 (`.md`, `ci.yml`, `Dockerfile`, `Makefile`) 的交叉比對，發現專案處於「精神分裂」狀態，不存在「單一事實來源」。
*   **關鍵學習**: 當不存在「單一事實」時，我的任務是將所有矛盾清晰地呈現給決策者，輔助您「創造」出一個新的、統一的、權威的決定。

### 2025-10-03 & 10-02: 在混亂中找到真相的漫長偵錯
*   **核心任務**: 為後端程式碼建立一個可執行的 Linting 基準線。
*   **偵錯歷程**: `lint` 報告致命錯誤，但 `test` 卻能通過。這個矛盾最終被證實是**測試覆蓋率為零**導致的。為推進主線，我們最終採取務實的工程決策，使用 `@pytest.mark.skip` 暫時跳過了另一個難以修復的阻塞性測試。
*   **關鍵學習**: 矛盾是通往真相的捷徑。務實主義有時高於完美主義。

### 2025-10-01: 測試驅動修復與SOP的價值
*   **核心任務**: 修復 `enduser-ui-fe` 中的兩個核心功能 Bug。
*   **偵錯歷程**: 完美展示了 TDD 偵錯閉環：修改元件 -> 測試失敗 -> 修復測試 -> 測試再次失敗 (揭示依賴問題) -> 修復依賴 -> 最終測試通過。過程中還透過查閱 SOP 解決了非同步 `alert` 的測試難題。
*   **關鍵學習**: SOP 是第一求助對象。警惕 Mock Data 的一致性，它是「改A壞B」的常見根源。

### 2025-09-30: 部署演練的真實挑戰
*   **核心任務**: 演練部署流程，並修復過程中發現的缺陷。
*   **偵錯歷程**: 依次解決了 (1) `archon-mcp` 因服務意外耦合導致的啟動失敗；(2) 因混淆「Deploy Hook URL」與「Git Remote」導致的 `git push` 失敗；(3) 因缺少 `pnpm-lock.yaml` 導致的前端建置失敗。
*   **關鍵學習**: 必須驗證所有服務；嚴格區分端點類型；鎖定檔案 (`lockfile`) 對於可重現建置至關重要。

### 2025-09-29: 在混亂的歷史中，找到唯一的真相
*   **核心任務**: 修正 `Makefile`，使其成為一個完整的檢查。
*   **偵錯歷程**: `git log -p` 揭示了驚人的真相：當前 `make test`「緩慢但完整」的狀態，是開發者在短時間內嘗試並**手動還原**了「快慢分離」方案後的**刻意選擇**。
*   **關鍵學習**: `git log -p` 是最終的仲裁者，能揭示開發者最真實、最終的意圖。

### 2025-09-27: 追溯真實的依賴關係與SOP的靈活應用
*   **核心任務**: 為非同步端點建立測試，並修復部署前檢查的阻塞性問題。
*   **偵錯歷程**: 透過 `search_file_content` 釐清了真實的類別依賴關係。為了避免 `make test` 的漫長等待，採納了「化整為零」的建議，改用 `make test-fe-single` 進行「微型驗證」。
*   **關鍵學習**: 信任程式碼定義，而非檔名。SOP 應靈活應用，可設計成本更低的「微型驗證」步驟來最高效率地達成目的。

### 2025-09-25: 突破 Mocking 迷霧
*   **核心任務**: 為一個重構後的異步端點修復測試。
*   **偵錯歷程**: 在 API 端點中臨時注入 `traceback` 日誌，捕獲到 `TypeError: object list can't be used in 'await' expression`，從而定位到問題是 `MagicMock` 回傳了同步的 `list`，而正確答案是使用 `AsyncMock`。
*   **關鍵學習**: 證據優於猜測。對於不確定的修復，先在隔離的臨時檔案中進行「沙盒驗證」，是保證穩定性的最佳實踐。

### 2025-09-24: 重構的安全網——特性測試
*   **核心任務**: 重構 `knowledge_api.py` 以移除直接的資料庫呼叫。
*   **偵錯歷程**: 最初的「直接重構」提議因風險過高被否決。在您的指導下，制定了以「測試先行」為核心的安全計畫：在修改任何程式碼**之前**，先為要修改的 API 編寫「特性測試 (Characterization Tests)」，用以鎖定其當前的行為。
*   **關鍵學習**: 對於沒有測試的遺留程式碼，重構的第一步永遠是補上測試，這就是確保不破壞既有功能的唯一方法。

### 2025-09-23: `make` 指令的副作用
*   **核心任務**: 解決 `current_user_role` 的技術債。
*   **偵錯歷程**: `make lint-be` 指令意外修改了上百個檔案。透過閱讀 `Makefile`，最終發現是 `lint-be` 指令中包含了 `--fix` 參數。
*   **關鍵學習**: 在使用專案的腳本前，必須先閱讀其原始碼 (`Makefile`)，理解其所有行為，特別是可能存在的副作用。

### 2025-09-22: 深挖根源，警惕次生錯誤
*   **核心任務**: 修復 `projects_api.py` 中的 `username` 欄位錯誤。
*   **偵錯歷程**: `pytest` 報錯 `AttributeError` 看似是導入路徑問題，但透過隔離診斷，才發現根源是更深層的 `ImportError: No module named 'cryptography'`。
*   **關鍵學習**: 必須找到失敗鏈中的第一個、最根本的失敗點，而不是只處理表面的次生錯誤。

### 2025-09-21: 追溯歷史意圖
*   **核心任務**: 在本地啟動完整的開發環境。
*   **偵錯歷程**: 後端服務因 `Invalid URL` 啟動失敗。透過查閱 `git log` 和 `Makefile`，確認了當前的 `docker-compose.yml` 設計是**故意**依賴 `make` 指令來傳遞環境變數，而非 `env_file`。
*   **關鍵學習**: 在提議「標準」方案前，必須先透過 `git log` 查證專案的歷史演進，理解現有設計的「原因」。

### 2025-09-19 & 09-18: 同步所有「事實」的副本
*   **核心任務**: 修復 `enduser-ui-fe` 的手動端對端測試。
*   **偵錯歷程**: 自動化測試通過，但手動測試失敗。根源在於，我只修正了測試檔中的假資料，卻忽略了應用程式在開發時真正依賴的 `api.ts` 中的主要假資料。
*   **關鍵學習**: 任何資料結構的變更，都必須確保所有相關的生產程式碼、測試程式碼和所有模擬資料都完全同步。

### 2025-09-17: 新的合作契約
*   **核心任務**: 在經歷了反覆的「改A壞B」循環後，重新建立工作方法。
*   **偵錯歷程**: 對過去數週的工作進行復盤。
*   **關鍵學習**: 建立了包含「目標優先、歷史為鑑、文件為綱、拒絕循環」的四項新工作原則。任何修改前，必須通盤分析所有相關檔案。
